import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { z } from 'zod';
import { logger } from '../utils/logger.js';
import { validateCodeInput } from '../utils/security.js';
import { 
  ErrorType, 
  createStandardError, 
  createErrorResponse, 
  validateBoundaries, 
  LIMITS 
} from '../utils/error-handler.js';
import { 
  validateMCPResponse, 
  validateGeneratedCode, 
  createStandardResponse 
} from '../utils/response-formatter.js';

/**
 * Roblox Luau code generation tool
 */
export const codeGenerator = {
  register: (server: McpServer) => {
    logger.info('Registering codeGenerator tool...');
    
    server.tool(
      'generate-roblox-code',
      'Generate Roblox Luau code for specific functionality',
      {
        scriptType: z.string().describe('Type of script (ServerScript, LocalScript, ModuleScript, Tool, GUI)'),
        functionality: z.string().describe('Description of what the script should do'),
        includeComments: z.boolean().optional().default(true).describe('Whether to include helpful comments'),
        framework: z.string().optional().default('none').describe('Framework to use (none, roact, etc.)')
      },
      async ({ scriptType, functionality, includeComments, framework }) => {
        try {
          // Boundary validation first
          validateBoundaries(functionality, LIMITS.MAX_FUNCTIONALITY_LENGTH, 'functionality', 'generate-roblox-code');
          validateBoundaries(scriptType, 50, 'scriptType', 'generate-roblox-code');
          if (framework) {
            validateBoundaries(framework, 50, 'framework', 'generate-roblox-code');
          }
          
          // Validate and sanitize functionality input for security
          const validationResult = validateCodeInput(functionality);
          
          if (!validationResult.isValid) {
            logger.warn('Code generation rejected due to security validation', {
              original: functionality,
              warnings: validationResult.warnings
            });
            const securityError = createStandardError(
              ErrorType.SECURITY_ERROR,
              `Input rejected for security reasons. ${validationResult.warnings.join('. ')}`,
              'generate-roblox-code',
              'functionality'
            );
            return createErrorResponse(securityError);
          }
          
          // Use sanitized input for code generation
          const code = generateRobloxCode(scriptType, validationResult.sanitized, includeComments ?? true, framework ?? 'none');
          
          // Validate generated code quality
          const codeValidation = validateGeneratedCode(code);
          
          let responseText = code;
          if (validationResult.warnings.length > 0) {
            responseText = `-- Security Notice: ${validationResult.warnings.join('. ')}\n\n${code}`;
          }
          
          // Add quality suggestions as comments if code quality is poor
          if (!codeValidation.isValid && codeValidation.suggestions.length > 0) {
            responseText = `-- Code Quality Notes: ${codeValidation.suggestions.join('. ')}\n\n${responseText}`;
          }
          
          const response = createStandardResponse(responseText, { includeTimestamp: true });
          
          // Validate MCP compliance
          const mcpValidation = validateMCPResponse(response);
          if (!mcpValidation.isValid) {
            logger.error('Generated response failed MCP validation', mcpValidation.errors);
            const validationError = createStandardError(
              ErrorType.INTERNAL_ERROR,
              'Generated response does not comply with MCP schema',
              'generate-roblox-code'
            );
            return createErrorResponse(validationError);
          }
          
          return response;
        } catch (error) {
          logger.error('Code generation failed:', error);
          
          // Handle standardized errors
          if (error && typeof error === 'object' && 'type' in error) {
            return createErrorResponse(error as any);
          }
          
          // Handle other errors
          const internalError = createStandardError(
            ErrorType.INTERNAL_ERROR,
            error instanceof Error ? error.message : 'Unknown error occurred during code generation',
            'generate-roblox-code'
          );
          return createErrorResponse(internalError);
        }
      }
    );
    
    logger.info('codeGenerator tool registered successfully');
  }
};

function generateRobloxCode(scriptType: string, functionality: string, includeComments: boolean, framework: string = 'none'): string {
  const comments = includeComments ? `-- ${scriptType} for ${functionality}\n-- Generated by Roblox MCP Server\n-- Framework: ${framework}\n\n` : '';
  
  let code = comments;
  
  switch (scriptType.toLowerCase()) {
    case 'serverscript':
      code += generateServerScript(functionality, framework, includeComments);
      break;
    case 'localscript':
      code += generateLocalScript(functionality, framework, includeComments);
      break;
    case 'modulescript':
      code += generateModuleScript(functionality, framework, includeComments);
      break;
    case 'tool':
      code += generateToolScript(functionality, includeComments);
      break;
    case 'gui':
      code += generateGUIScript(functionality, includeComments);
      break;
    default:
      code += generateGenericScript(functionality, includeComments);
  }
  
  return code;
}

function generateServerScript(functionality: string, framework: string, includeComments: boolean): string {
  const comment = includeComments ? '-- Server-side script\n' : '';
  let services = 'local Players = game:GetService("Players")\nlocal ReplicatedStorage = game:GetService("ReplicatedStorage")\n';
  
  if (functionality.toLowerCase().includes('datastore')) {
    services += 'local DataStoreService = game:GetService("DataStoreService")\n';
  }
  if (functionality.toLowerCase().includes('teleport')) {
    services += 'local TeleportService = game:GetService("TeleportService")\n';
  }
  if (functionality.toLowerCase().includes('market')) {
    services += 'local MarketplaceService = game:GetService("MarketplaceService")\n';
  }
  
  let implementation = '';
  if (functionality.toLowerCase().includes('player join')) {
    implementation = `
Players.PlayerAdded:Connect(function(player)
    ${includeComments ? '-- Handle new player joining' : ''}
    print("Player joined:", player.Name)
    ${includeComments ? '-- Add your player setup logic here' : ''}
end)

Players.PlayerRemoving:Connect(function(player)
    ${includeComments ? '-- Handle player leaving' : ''}
    print("Player leaving:", player.Name)
    ${includeComments ? '-- Add cleanup logic here' : ''}
end)`;
  } else if (functionality.toLowerCase().includes('datastore')) {
    implementation = `
local dataStore = DataStoreService:GetDataStore("${functionality.replace(/\s+/g, '')}")

function savePlayerData(player, data)
    local success, errorMessage = pcall(function()
        dataStore:SetAsync(player.UserId, data)
    end)
    if not success then
        warn("Failed to save data for " .. player.Name .. ": " .. errorMessage)
    end
end

function loadPlayerData(player)
    local success, data = pcall(function()
        return dataStore:GetAsync(player.UserId)
    end)
    if success then
        return data
    else
        warn("Failed to load data for " .. player.Name)
        return nil
    end
end`;
  } else {
    implementation = `
${includeComments ? '-- Implementation for: ' + functionality : ''}
function ${functionality.replace(/\s+/g, '').toLowerCase()}()
    ${includeComments ? '-- Add your implementation here' : ''}
    print("${functionality} executed")
end

${functionality.replace(/\s+/g, '').toLowerCase()}()`;
  }
  
  return comment + services + '\n' + implementation;
}

function generateLocalScript(functionality: string, framework: string, includeComments: boolean): string {
  const comment = includeComments ? '-- Client-side script\n' : '';
  let services = 'local Players = game:GetService("Players")\nlocal UserInputService = game:GetService("UserInputService")\nlocal player = Players.LocalPlayer\n';
  
  if (functionality.toLowerCase().includes('gui') || functionality.toLowerCase().includes('ui')) {
    services += 'local StarterGui = game:GetService("StarterGui")\n';
  }
  if (functionality.toLowerCase().includes('camera')) {
    services += 'local Camera = workspace.CurrentCamera\n';
  }
  if (functionality.toLowerCase().includes('sound') || functionality.toLowerCase().includes('audio')) {
    services += 'local SoundService = game:GetService("SoundService")\n';
  }
  
  let implementation = '';
  if (functionality.toLowerCase().includes('input') || functionality.toLowerCase().includes('key')) {
    implementation = `
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    if input.KeyCode == Enum.KeyCode.E then
        ${includeComments ? '-- Handle E key press' : ''}
        print("E key pressed")
        ${includeComments ? '-- Add your input handling here' : ''}
    end
end)`;
  } else if (functionality.toLowerCase().includes('gui')) {
    implementation = `
local screenGui = Instance.new("ScreenGui")
screenGui.Parent = player:WaitForChild("PlayerGui")

local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 200, 0, 100)
frame.Position = UDim2.new(0.5, -100, 0.5, -50)
frame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
frame.Parent = screenGui

local textLabel = Instance.new("TextLabel")
textLabel.Size = UDim2.new(1, 0, 1, 0)
textLabel.Text = "${functionality}"
textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
textLabel.BackgroundTransparency = 1
textLabel.Parent = frame`;
  } else {
    implementation = `
${includeComments ? '-- Implementation for: ' + functionality : ''}
function ${functionality.replace(/\s+/g, '').toLowerCase()}()
    ${includeComments ? '-- Add your client-side implementation here' : ''}
    print("Client: ${functionality} executed")
end

${functionality.replace(/\s+/g, '').toLowerCase()}()`;
  }
  
  return comment + services + '\n' + implementation;
}

function generateModuleScript(functionality: string, framework: string, includeComments: boolean): string {
  const comment = includeComments ? '-- Module script\n' : '';
  const moduleName = functionality.replace(/\s+/g, '') + 'Module';
  
  return comment + `local ${moduleName} = {}

${includeComments ? '-- Module for: ' + functionality : ''}

function ${moduleName}.init()
    ${includeComments ? '-- Initialize the module' : ''}
    print("${moduleName} initialized")
end

function ${moduleName}.${functionality.replace(/\s+/g, '').toLowerCase()}()
    ${includeComments ? '-- Implementation for: ' + functionality : ''}
    print("${functionality} executed")
end

${includeComments ? '-- Add more functions as needed' : ''}

return ${moduleName}`;
}

function generateToolScript(functionality: string, includeComments: boolean): string {
  const comment = includeComments ? '-- Tool script\n' : '';
  
  return comment + `local tool = script.Parent
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local mouse = player:GetMouse()

tool.Activated:Connect(function()
    ${includeComments ? '-- Handle tool activation' : ''}
    print("Tool activated: ${functionality}")
    ${includeComments ? '-- Add your tool logic here' : ''}
end)

tool.Equipped:Connect(function()
    ${includeComments ? '-- Handle tool equipped' : ''}
    print("Tool equipped")
end)

tool.Unequipped:Connect(function()
    ${includeComments ? '-- Handle tool unequipped' : ''}
    print("Tool unequipped")
end)`;
}

function generateGUIScript(functionality: string, includeComments: boolean): string {
  const comment = includeComments ? '-- GUI script\n' : '';
  
  return comment + `local Players = game:GetService("Players")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

${includeComments ? '-- Create main GUI' : ''}
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "${functionality.replace(/\s+/g, '')}GUI"
screenGui.Parent = playerGui

local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.new(0, 400, 0, 300)
mainFrame.Position = UDim2.new(0.5, -200, 0.5, -150)
mainFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
mainFrame.BorderSizePixel = 0
mainFrame.Parent = screenGui

${includeComments ? '-- Add GUI elements' : ''}
local titleLabel = Instance.new("TextLabel")
titleLabel.Name = "Title"
titleLabel.Size = UDim2.new(1, 0, 0, 50)
titleLabel.Position = UDim2.new(0, 0, 0, 0)
titleLabel.Text = "${functionality}"
titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
titleLabel.TextScaled = true
titleLabel.BackgroundTransparency = 1
titleLabel.Parent = mainFrame

${includeComments ? '-- Add close button' : ''}
local closeButton = Instance.new("TextButton")
closeButton.Name = "CloseButton"
closeButton.Size = UDim2.new(0, 30, 0, 30)
closeButton.Position = UDim2.new(1, -35, 0, 5)
closeButton.Text = "X"
closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
closeButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
closeButton.BorderSizePixel = 0
closeButton.Parent = mainFrame

closeButton.Activated:Connect(function()
    screenGui:Destroy()
end)`;
}

function generateGenericScript(functionality: string, includeComments: boolean): string {
  return `${includeComments ? '-- Generic script for: ' + functionality + '\n' : ''}print("${functionality} script loaded")

${includeComments ? '-- Add your implementation here' : ''}
function main()
    ${includeComments ? '-- Main function for: ' + functionality : ''}
    print("Executing: ${functionality}")
end

main()`;
}